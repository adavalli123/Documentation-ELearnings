**SOLID PRINCIPLES**

```
S - Single Responsibility Principle
O - Open for Extension & Close for Modification
L - Liskov Substitution Principle
I - Interface Segregation
D - Dependency Inversion.
```

**1. SRP:**
- THERE SHOULD NEVER BE MORE THAN ONE REASON FOR A CLASS TO CHANGE.

Ex: 
```
class Handler {
  func parse() {
  // Do something related to parsing 
  }

  func apiCall() {
  // Do something related to networkCall
  }

  func saveToDB() {
  // Do something related to saving in DB
  }
}
```

Here class is involved in making a networkCall, parsing the data & saving it to the database.

**Following this Principle:**
Each class should perform only related task.

```
class Storing {
  func saveToDB() {
  // Do something related to saving in DB
  }
}
```

Advantages:
1. This Principle helps the class to be in clean state.
2. It helps to test components independently (which means writing test cases is easier)



**2. Open For Extension & Close for Modification**
- SOFTWARE ENTITIES (CLASSES, MODULES, FUNCTIONS, ETC.) SHOULD BE OPEN FOR EXTENSION, BUT CLOSED FOR MODIFICATION.

Advantages:
1. Less Defects, because we are not modifying the behavior of existing class.
2. Open to add functionality.

**Liskov Substitution Principle**
- FUNCTIONS THAT USE POINTERS OR REFERENCES TO BASE CLASSES MUST BE ABLE TO USE OBJECTS OF DERIVED CLASSES WITHOUT KNOWING IT.




